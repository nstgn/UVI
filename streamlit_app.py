import streamlit as st
from streamlit_gsheets import GSheetsConnection

url = "https://docs.google.com/spreadsheets/d/1SczaIV1JHUSca1hPilByJFFzOi5a8Hkhi0OemlmPQsY/edit?usp=sharing"
conn = st.connection("gsheets", type=GSheetsConnection)

#data = conn.read(worksheet="Sheet1")
data = conn.read(spreadsheet=url, usecols=[0, 1, 2])
st.dataframe(data)

# -*- coding: utf-8 -*-
"""UV Colab.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IJat6KJhVulh0zmo3R1t5RH5ROgiUs1j
"""

#1 Import Library
import numpy as np
import pandas as pd
import tensorflow as tf
from sklearn.preprocessing import MinMaxScaler
from sklearn.model_selection import train_test_split
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout
from tensorflow.keras.utils import plot_model
from datetime import datetime, timedelta
from statsmodels.tsa.seasonal import seasonal_decompose
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score

# Visualization
import matplotlib.pyplot as plt
import plotly.express as px

# Data spreadsheet
import gspread
from google.auth import default
from google.auth.transport.requests import Request
from google.oauth2.credentials import Credentials

#2 Input Data
# Otentikasi Google
auth.authenticate_user()
creds, _ = default()
gc = gspread.authorize(creds)

# Buka Google Sheet
sheet_url = "https://docs.google.com/spreadsheets/d/1SczaIV1JHUSca1hPilByJFFzOi5a8Hkhi0OemlmPQsY/edit?gid=0#gid=0"
worksheet = gc.open_by_url(sheet_url).sheet1

# Baca data ke dalam dataframe
data = pd.DataFrame(worksheet.get_all_records(expected_headers=[ "Time", "Intensity"]))

# Tampilkan data
print(data)
plt.plot(data[['Intensity']])

#3 Pre-Processing Data
#data = data[['Time', 'Intensity']].copy().dropna()
#data.reset_index(drop=True, inplace=True)

# Fungsi untuk loop utama memeriksa data
def main_loop():
    previous_data_hash = None  # Untuk memeriksa apakah data telah berubah

    while True:
        # Ambil data terbaru
        data = fetch_latest_data()
        data_hash = hash(data.to_string())  # Membuat hash untuk mendeteksi perubahan data

        if data_hash != previous_data_hash:  # Jika data berubah
            print(f"Data diperbarui pada {datetime.now()}")
            previous_data_hash = data_hash

            # Pre-processing data terbaru
            data = data[['Time', 'Intensity']].dropna()
            data.reset_index(drop=True, inplace=True)
            data['data_scaled'] = scaler.fit_transform(data[['Intensity']])

            # Siapkan data untuk pelatihan
            X, y = prepare_data(data['data_scaled'].values, n_steps)

            # Split data
            split = int(len(X) * 0.8)
            X_train, X_test = X[:split], X[split:]
            y_train, y_test = y[:split], y[split:]

            # Reshape data
            X_train = X_train.reshape((X_train.shape[0], X_train.shape[1], 1))
            X_test = X_test.reshape((X_test.shape[0], X_test.shape[1], 1))

            # Latih model dengan data baru
            model.fit(X_train, y_train, epochs=10, batch_size=32, validation_data=(X_test, y_test), verbose=1)

        else:
            print(f"Tidak ada perubahan data. Memeriksa lagi dalam 60 detik...")

        # Tunggu sebelum memeriksa lagi
        time.sleep(60)

#4 Normalisasi Data
scaler = MinMaxScaler(feature_range=(0, 1))
data ['data_scaled'] = scaler.fit_transform(data[['Intensity']])
print(data['data_scaled'])

#5 Inisialisasi Timestep
def prepare_data(series, n_steps):
    X, y = [], []
    for i in range(len(series)-n_steps):
        X.append(series[i:i+n_steps])
        y.append(series[i+n_steps])
    return np.array(X), np.array(y)

n_steps = 3
X, y = prepare_data(data['data_scaled'].values, n_steps)
print("X:", X)
print("y:", y)

#6 Split Data
split = int(len(X) * 0.8)
X_train, X_test = X[:split], X[split:]
y_train, y_test = y[:split], y[split:]

# Reshape input [samples, time steps, features]
X_train = X_train.reshape((X_train.shape[0], X_train.shape[1], 1))
X_test = X_test.reshape((X_test.shape[0], X_test.shape[1], 1))

print(X_train.shape, y_train.shape)
print(X_test.shape, y_test.shape)

# Visualisasi Data Train dan Test
plt.figure(figsize=(5, 3))
plt.plot(range(len(y_train)), y_train, label='Data Train', color='purple')
plt.plot(range(len(y_train), len(y_train) + len(y_test)), y_test, label='Data Test', color='green')
plt.title("Data Train dan Data Test")
plt.xlabel("Index") #karna default untuk urutan aja, jadi ya ga perlu pake
plt.ylabel("Scaled Intensity")
plt.legend()

#7 Bangun LSTM
model = Sequential([
    LSTM(50, activation='relu', input_shape=(n_steps, 1), return_sequences=True),
    Dropout(0.1),
    LSTM(50, activation='relu'),
    Dense(1)
])

#8 Pembuatan Model dan Kompilasi Model
model.compile(optimizer='adam', loss='mean_squared_error')

#9 Pelatihan Model
history=model.fit(X_train, y_train, epochs=200, batch_size=32, validation_data=(X_test, y_test), verbose=1)

# visualisasi Pelatihan Model
plt.plot(history.history['loss'], label='Training Loss')
plt.plot(history.history['val_loss'], label='Validation Loss')
plt.xlabel('Epochs')
plt.ylabel('Loss')
plt.title('Training and Validation Loss')
plt.legend()
plt.show()

model.summary()

#10 Prediksi Model
train_predicted = model.predict(X_train)
test_predicted = model.predict(X_test)

#11 Evaluasi Model
#Evaluasi untuk data training
mse_train = mean_squared_error(y_train,train_predicted)
rmse_train = np.sqrt(mse_train)
mae_train = mean_absolute_error(y_train, train_predicted)
r2_train = r2_score(y_train,train_predicted)*100

#Evaluasi untuk data testing
mse_test = mean_squared_error(y_test, test_predicted)
rmse_test =np.sqrt(mse_test)
mae_test = mean_absolute_error(y_test, test_predicted)
r2_test = r2_score(y_test, test_predicted)*100

# Menampilkan hasil evaluasi
print("Training Metrics:")
print(f"MSE: {mse_train:.4f}, RMSE: {rmse_train:.4f}, MAE: {mae_train:.4f}, R²: {r2_train:.2f}%")
print("\nTesting Metrics:")
print(f"MSE: {mse_test:.4f}, RMSE: {rmse_test:.4f}, MAE: {mae_test:.4f}, R²: {r2_test:.2f}%")

#13 Visualisasi Data
import seaborn as sns
sns.set_style("darkgrid")
train_actual = scaler.inverse_transform(y_train.reshape(-1, 1))
train_predicted = scaler.inverse_transform(train_predicted)
test_actual = scaler.inverse_transform(y_test.reshape(-1, 1))
test_predicted = scaler.inverse_transform(test_predicted)

plt.figure(figsize=(5,3))
plt.plot(test_actual, color='blue', label='Actual intensity')
plt.plot(test_predicted, color='red', linestyle='--', label='Predicted intensity')
plt.title('intensity Prediction')
plt.xlabel('Steps')
plt.ylabel('intensity')
plt.legend()
plt.show()

plt.figure(figsize=(5, 3))
plt.plot(range(len(train_actual)), train_actual, label='Actual Train', color='blue')
plt.plot(range(len(train_actual), len(train_actual) + len(test_actual)), test_actual, label='Actual Test', color='green')
plt.plot(range(len(train_predicted)), train_predicted, label='Predicted Train', color='red')
plt.plot(range(len(train_predicted), len(train_predicted) + len(test_predicted)), test_predicted, label='Predicted Test', color='orange')
plt.title('Prediksi vs Aktual (Latih dan Uji)')
plt.xlabel('Time')
plt.ylabel('Intensity')
plt.legend()
plt.show()

#12 Future Predictions with Time
future_steps = 10
last_sequence = X_test[-1]
future_predictions = []

# Ambil waktu terakhir dari dataset asli
last_time = pd.to_datetime(data['Time'].iloc[-1])

# Hitung interval waktu (dalam detik) antara pengukuran
time_interval = (pd.to_datetime(data['Time'].iloc[1]) - pd.to_datetime(data['Time'].iloc[0])).seconds

# Generate prediksi ke depan
future_times = []
for step in range(future_steps):
    # Prediksi langkah ke depan
    prediction = model.predict(last_sequence.reshape(1, n_steps, 1))[0, 0]
    future_predictions.append(prediction)
    last_sequence = np.append(last_sequence[1:], prediction)

    # Perbarui waktu ke depan
    last_time += pd.to_timedelta(time_interval, unit='s')
    future_times.append(last_time)

# Inversi normalisasi hasil prediksi
future_predictions_scaled = scaler.inverse_transform(np.array(future_predictions).reshape(-1, 1))

# Simpan hasil dalam DataFrame
future_df = pd.DataFrame({
    'Time': future_times,
    'Predicted Intensity': future_predictions_scaled.flatten()
})

# Tampilkan tabel hasil prediksi
print(future_df)

# Visualisasi hasil prediksi ke depan
plt.figure(figsize=(8, 4))
plt.plot(future_df['Time'], future_df['Predicted Intensity'], color='orange', marker='o', label='Future Predictions')
plt.title('Future Predictions Over Time')
plt.xlabel('Time')
plt.ylabel('Predicted Intensity')
plt.grid(True)
plt.legend()
plt.xticks(rotation=45)
plt.show()

#12 Future Predictions
future_steps = 10  # Jumlah langkah ke depan yang ingin diprediksi
last_sequence = X_test[-1]  # Ambil data terakhir dari X_test
future_predictions = []

for _ in range(future_steps):
    # Prediksi langkah ke depan
    prediction = model.predict(last_sequence.reshape(1, n_steps, 1))[0, 0]
    future_predictions.append(prediction)

    # Tambahkan prediksi ke urutan terakhir untuk prediksi berikutnya
    last_sequence = np.append(last_sequence[1:], prediction)

# Inversi normalisasi hasil prediksi
future_predictions_scaled = scaler.inverse_transform(np.array(future_predictions).reshape(-1, 1))

# Simulasikan langkah waktu ke depan
future_times = range(len(data) + 1, len(data) + 1 + future_steps)

# Visualisasi Prediksi Masa Depan
plt.figure(figsize=(7, 4))
plt.plot(range(len(test_actual)), test_actual, label='Actual Data', color='blue')
plt.plot(range(len(test_actual)), test_predicted, label='Predicted Data', color='red', linestyle='--')
plt.plot(future_times, future_predictions_scaled, label='Future Predictions', color='green', linestyle=':')
plt.title('Intensity Prediction with Future Predictions')
plt.xlabel('Steps')
plt.ylabel('Intensity')
plt.legend()
plt.show()

# Tampilkan prediksi masa depan
for i, pred in enumerate(future_predictions_scaled.flatten(), 1):
    print(f"Prediction for future step {i}: {pred:.2f} intensity")
